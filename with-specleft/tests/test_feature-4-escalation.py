"""
Auto-generated skeleton tests from Markdown specs.
Regenerate using: specleft test skeleton

Generated by SpecLeft - https://github.com/SpecLeft/specleft
"""

import pytest
from datetime import datetime, timedelta, timezone

from specleft import specleft
from tests.helpers import create_and_submit_document, approve_document

# =============================================================================
# Feature: 4: Escalation
# ID: feature-4-escalation
# Documents that remain in review without action should automatically escalate.
# =============================================================================

# Story: Default
# ID: default


@specleft(
    feature_id="feature-4-escalation",
    scenario_id="auto-escalate-after-configurable-timeout",
)
def test_auto_escalate_after_configurable_timeout(client, db_session):
    """Auto-escalate after configurable timeout

    Priority: high
    """
    with specleft.step('Given a document in "review" status'):
        doc = create_and_submit_document(client, reviewer_ids=["reviewer-1"])

    with specleft.step(
        "When the configured timeout period elapses without all reviewers acting"
    ):
        from app.models import Document

        db_doc = db_session.query(Document).filter(Document.id == doc["id"]).first()
        db_doc.review_started_at = datetime.now(timezone.utc) - timedelta(hours=25)
        db_session.commit()

        resp = client.post(
            f"/api/documents/{doc['id']}/escalate",
            json={
                "timeout_hours": 24,
                "next_approver_id": "manager-1",
            },
        )

    with specleft.step("Then the document is escalated to the next-level approver"):
        assert resp.status_code == 200
        data = resp.json()
        assert data["escalated"] is True
        assert data["escalated_to"] == "manager-1"

    with specleft.step("And the escalation is recorded with a timestamp"):
        assert data["escalation_level"] == 1


@specleft(
    feature_id="feature-4-escalation",
    scenario_id="escalation-notifies-next-level-approver",
)
def test_escalation_notifies_next_level_approver(client, db_session):
    """Escalation notifies next-level approver

    Priority: high
    """
    with specleft.step("Given a document that has been escalated"):
        doc = create_and_submit_document(client, reviewer_ids=["reviewer-1"])
        from app.models import Document

        db_doc = db_session.query(Document).filter(Document.id == doc["id"]).first()
        db_doc.review_started_at = datetime.now(timezone.utc) - timedelta(hours=25)
        db_session.commit()

    with specleft.step("When the escalation is triggered"):
        resp = client.post(
            f"/api/documents/{doc['id']}/escalate",
            json={
                "timeout_hours": 24,
                "next_approver_id": "manager-1",
            },
        )
        assert resp.json()["escalated"] is True

    with specleft.step("Then the next-level approver is added to the reviewer list"):
        status = client.get(f"/api/documents/{doc['id']}/status").json()
        assert "manager-1" in status["reviewers"]

    with specleft.step("And a notification is generated for the new approver"):
        assert "manager-1" in status["pending_reviewers"]


@specleft(
    feature_id="feature-4-escalation",
    scenario_id="original-reviewer-can-still-approve-before-escalation-triggers",
)
def test_original_reviewer_can_still_approve_before_escalation_triggers(
    client, db_session
):
    """Original reviewer can still approve before escalation triggers

    Priority: high
    """
    with specleft.step("Given a document approaching the escalation timeout"):
        doc = create_and_submit_document(client, reviewer_ids=["reviewer-1"])

    with specleft.step(
        "When the original reviewer submits their decision before the timeout"
    ):
        approve_document(client, doc["id"], "reviewer-1")

    with specleft.step("Then the escalation is cancelled"):
        from app.models import Document

        db_doc = db_session.query(Document).filter(Document.id == doc["id"]).first()
        db_doc.review_started_at = datetime.now(timezone.utc) - timedelta(hours=25)
        db_session.commit()

        resp = client.post(
            f"/api/documents/{doc['id']}/escalate",
            json={
                "timeout_hours": 24,
                "next_approver_id": "manager-1",
            },
        )

    with specleft.step("And the document proceeds through normal approval flow"):
        # Document is already approved, so the escalate endpoint returns 409
        assert resp.status_code == 409 or resp.json().get("escalated") is False


@specleft(
    feature_id="feature-4-escalation",
    scenario_id="escalation-resets-timeout-for-new-approver",
)
def test_escalation_resets_timeout_for_new_approver(client, db_session):
    """Escalation resets timeout for new approver

    Priority: high
    """
    with specleft.step("Given a document that has been escalated to a new approver"):
        doc = create_and_submit_document(client, reviewer_ids=["reviewer-1"])
        from app.models import Document

        db_doc = db_session.query(Document).filter(Document.id == doc["id"]).first()
        db_doc.review_started_at = datetime.now(timezone.utc) - timedelta(hours=25)
        db_session.commit()

        resp1 = client.post(
            f"/api/documents/{doc['id']}/escalate",
            json={
                "timeout_hours": 24,
                "next_approver_id": "manager-1",
            },
        )
        assert resp1.json()["escalated"] is True

    with specleft.step("When the escalation is processed"):
        resp2 = client.post(
            f"/api/documents/{doc['id']}/escalate",
            json={
                "timeout_hours": 24,
                "next_approver_id": "manager-2",
            },
        )

    with specleft.step("Then a new timeout period begins for the escalated approver"):
        data = resp2.json()
        assert data["escalated"] is False

    with specleft.step("And the original timeout is no longer active"):
        assert data["reason"] == "Timeout has not elapsed"


@specleft(
    feature_id="feature-4-escalation",
    scenario_id="maximum-escalation-depth-is-enforced",
)
def test_maximum_escalation_depth_is_enforced(client, db_session):
    """Maximum escalation depth is enforced

    Priority: high
    """
    with specleft.step(
        "Given a document that has already been escalated to the maximum depth"
    ):
        doc = create_and_submit_document(client, reviewer_ids=["reviewer-1"])
        from app.models import Document, Escalation

        db_doc = db_session.query(Document).filter(Document.id == doc["id"]).first()
        db_doc.max_escalation_depth = 3

        for i in range(3):
            # Backdate the reference time so the timeout has elapsed
            if i == 0:
                db_doc.review_started_at = datetime.now(timezone.utc) - timedelta(
                    hours=25
                )
            else:
                # Backdate the last escalation's timestamp
                last_esc = (
                    db_session.query(Escalation)
                    .filter(Escalation.document_id == doc["id"])
                    .order_by(Escalation.escalated_at.desc())
                    .first()
                )
                last_esc.escalated_at = datetime.now(timezone.utc) - timedelta(hours=25)
            db_session.commit()
            resp = client.post(
                f"/api/documents/{doc['id']}/escalate",
                json={
                    "timeout_hours": 24,
                    "next_approver_id": f"manager-{i + 1}",
                },
            )
            assert resp.json()["escalated"] is True, (
                f"Escalation {i + 1} failed: {resp.json()}"
            )

    with specleft.step("When the escalation timeout elapses again"):
        db_session.refresh(db_doc)
        last_esc = (
            db_session.query(Escalation)
            .filter(Escalation.document_id == doc["id"])
            .order_by(Escalation.escalated_at.desc())
            .first()
        )
        last_esc.escalated_at = datetime.now(timezone.utc) - timedelta(hours=25)
        db_session.commit()

        resp = client.post(
            f"/api/documents/{doc['id']}/escalate",
            json={
                "timeout_hours": 24,
                "next_approver_id": "manager-4",
            },
        )

    with specleft.step("Then no further escalation occurs"):
        data = resp.json()
        assert data["escalated"] is False

    with specleft.step(
        "And an error or warning is logged indicating max depth reached"
    ):
        assert "maximum escalation depth" in data["reason"].lower()

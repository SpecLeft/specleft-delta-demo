"""
Auto-generated skeleton tests from Markdown specs.
Regenerate using: specleft test skeleton

Generated by SpecLeft - https://github.com/SpecLeft/specleft
"""

from specleft import specleft

from tests.helpers import (
    create_document,
    get_document,
    list_notifications,
    submit_document,
    submit_document_with_start_time,
    trigger_escalation,
)

# =============================================================================
# Feature: 4: Escalation
# ID: feature-4-escalation
# --- confidence: medium source: prd assumptions: - Escalation timeouts are stored per document (in hours). - Escalation adds a reviewer from an escalation ladder table. tags: - escalation - workflow component: api ---
# =============================================================================

# Story: Default
# ID: default


@specleft(
    feature_id="feature-4-escalation",
    scenario_id="auto-escalate-after-configurable-timeout",
)
def test_auto_escalate_after_configurable_timeout(client):
    """Auto-escalate after configurable timeout

    Priority: medium
    """
    with specleft.step('Given a document in "review" status'):
        author_id = "author-1"
        reviewer_id = "reviewer-1"
        create_response = create_document(client, author_id=author_id)
        document_id = create_response.json()["id"]
        submit_document_with_start_time(
            client,
            document_id=document_id,
            author_id=author_id,
            reviewer_ids=[reviewer_id],
            escalation={"timeout_hours": 24, "ladder": ["manager-1"]},
            start_at="2030-12-31T00:00:00Z",
        )

    with specleft.step(
        "When the configured timeout period elapses without all reviewers acting"
    ):
        trigger_response = trigger_escalation(
            client, document_id=document_id, now="2031-01-01T01:00:00Z"
        )
        assert trigger_response.status_code == 200
        trigger_payload = trigger_response.json()

    with specleft.step("Then the document is escalated to the next-level approver"):
        assert trigger_payload["escalation"]["escalated_to"] == "manager-1"

    with specleft.step("And the escalation is recorded with a timestamp"):
        assert trigger_payload["escalation"]["escalated_at"]


@specleft(
    feature_id="feature-4-escalation",
    scenario_id="escalation-notifies-next-level-approver",
)
def test_escalation_notifies_next_level_approver(client):
    """Escalation notifies next-level approver

    Priority: medium
    """
    with specleft.step("Given a document that has been escalated"):
        author_id = "author-1"
        reviewer_id = "reviewer-1"
        create_response = create_document(client, author_id=author_id)
        document_id = create_response.json()["id"]
        submit_document_with_start_time(
            client,
            document_id=document_id,
            author_id=author_id,
            reviewer_ids=[reviewer_id],
            escalation={"timeout_hours": 1, "ladder": ["manager-1"]},
            start_at="2031-01-01T00:00:00Z",
        )
        trigger_escalation(client, document_id=document_id, now="2031-01-01T01:00:00Z")

    with specleft.step("When the escalation is triggered"):
        notification_response = list_notifications(client, document_id=document_id)
        assert notification_response.status_code == 200
        notification_payload = notification_response.json()

    with specleft.step("Then the next-level approver is added to the reviewer list"):
        fetch_response = get_document(client, document_id=document_id)
        assert "manager-1" in fetch_response.json()["reviewer_ids"]

    with specleft.step("And a notification is generated for the new approver"):
        recipients = {item["recipient_id"] for item in notification_payload["items"]}
        assert "manager-1" in recipients


@specleft(
    feature_id="feature-4-escalation",
    scenario_id="escalation-resets-timeout-for-new-approver",
)
def test_escalation_resets_timeout_for_new_approver(client):
    """Escalation resets timeout for new approver

    Priority: medium
    """
    with specleft.step("Given a document that has been escalated to a new approver"):
        author_id = "author-1"
        reviewer_id = "reviewer-1"
        create_response = create_document(client, author_id=author_id)
        document_id = create_response.json()["id"]
        submit_document_with_start_time(
            client,
            document_id=document_id,
            author_id=author_id,
            reviewer_ids=[reviewer_id],
            escalation={"timeout_hours": 1, "ladder": ["manager-1", "director-1"]},
            start_at="2031-01-01T00:00:00Z",
        )
        trigger_escalation(client, document_id=document_id, now="2031-01-01T01:00:00Z")

    with specleft.step("When the escalation is processed"):
        second_trigger = trigger_escalation(
            client, document_id=document_id, now="2031-01-01T01:30:00Z"
        )
        assert second_trigger.status_code == 409
        trigger_payload = second_trigger.json()

    with specleft.step("Then a new timeout period begins for the escalated approver"):
        assert trigger_payload["error"]["code"] == "escalation_not_due"

    with specleft.step("And the original timeout is no longer active"):
        assert "next_escalation_at" in trigger_payload["error"]["meta"]


@specleft(
    feature_id="feature-4-escalation",
    scenario_id="notes-3",
)
def test_notes_3(client):
    """Notes

    Priority: high
    """
    with specleft.step(
        "Then escalation timeout is configurable per document or organization"
    ):
        author_id = "author-1"
        reviewer_id = "reviewer-1"
        document_id = create_document(client, author_id=author_id).json()["id"]
        submit_document_with_start_time(
            client,
            document_id=document_id,
            author_id=author_id,
            reviewer_ids=[reviewer_id],
            escalation={"timeout_hours": 2, "ladder": ["manager-1"]},
            start_at="2031-01-01T00:00:00Z",
        )
        trigger = trigger_escalation(
            client, document_id=document_id, now="2031-01-01T01:00:00Z"
        )
        assert trigger.status_code == 409

    with specleft.step("And maximum escalation depth is enforced"):
        trigger = trigger_escalation(
            client, document_id=document_id, now="2031-01-02T01:00:00Z"
        )
        assert trigger.status_code == 200
        exhausted = trigger_escalation(
            client, document_id=document_id, now="2031-01-03T01:00:00Z"
        )
        assert exhausted.status_code == 409
        assert exhausted.json()["error"]["code"] == "escalation_max_depth"


@specleft(
    feature_id="feature-4-escalation",
    scenario_id="original-reviewer-can-still-approve-before-escalation-triggers",
)
def test_original_reviewer_can_still_approve_before_escalation_triggers(client):
    """Original reviewer can still approve before escalation triggers

    Priority: medium
    """
    with specleft.step("Given a document approaching the escalation timeout"):
        author_id = "author-1"
        reviewer_id = "reviewer-1"
        document_id = create_document(client, author_id=author_id).json()["id"]
        submit_document_with_start_time(
            client,
            document_id=document_id,
            author_id=author_id,
            reviewer_ids=[reviewer_id],
            escalation={"timeout_hours": 2, "ladder": ["manager-1"]},
            start_at="2031-01-01T00:00:00Z",
        )

    with specleft.step(
        "When the original reviewer submits their decision before the timeout"
    ):
        approve_response = client.post(
            f"/documents/{document_id}/reviews/approve",
            json={"actor_id": reviewer_id},
        )
        assert approve_response.status_code == 200

    with specleft.step("Then the escalation is cancelled"):
        trigger = trigger_escalation(
            client, document_id=document_id, now="2031-01-01T05:00:00Z"
        )
        assert trigger.status_code == 409
        assert trigger.json()["error"]["code"] == "escalation_not_applicable"

    with specleft.step("And the document proceeds through normal approval flow"):
        fetch_response = get_document(client, document_id=document_id)
        assert fetch_response.json()["status"] == "approved"

"""
Auto-generated skeleton tests from Markdown specs.
Regenerate using: specleft test skeleton

Generated by SpecLeft - https://github.com/SpecLeft/specleft
"""

from specleft import specleft

from tests.helpers import (
    assert_error,
    approve_document,
    create_delegation,
    create_document,
    submit_document,
)

# =============================================================================
# Feature: 3: Delegation
# ID: feature-3-delegation
# --- confidence: medium source: prd assumptions: - Delegation applies per document only. - A reviewer can have at most one active delegation per document. tags: - delegation - workflow component: api ---
# =============================================================================

# Story: Default
# ID: default


@specleft(
    feature_id="feature-3-delegation",
    scenario_id="delegate-review-to-substitute-with-expiry-date",
)
def test_delegate_review_to_substitute_with_expiry_date(client):
    """Delegate review to substitute with expiry date

    Priority: medium
    """
    with specleft.step("Given a reviewer assigned to a document"):
        author_id = "author-1"
        delegator_id = "reviewer-1"
        substitute_id = "reviewer-2"
        create_response = create_document(client, author_id=author_id)
        document_id = create_response.json()["id"]
        submit_document(
            client,
            document_id=document_id,
            author_id=author_id,
            reviewer_ids=[delegator_id],
        )

    with specleft.step("When they delegate to a substitute with an expiry date"):
        delegation_response = create_delegation(
            client,
            document_id=document_id,
            delegator_id=delegator_id,
            substitute_id=substitute_id,
            expires_at="2031-01-01T00:00:00Z",
        )
        assert delegation_response.status_code == 201
        delegation_payload = delegation_response.json()

    with specleft.step(
        "Then the substitute is granted review permissions for that document"
    ):
        assert delegation_payload["substitute_id"] == substitute_id
        assert delegation_payload["delegator_id"] == delegator_id

    with specleft.step("And the delegation record includes the expiry timestamp"):
        assert delegation_payload["expires_at"] == "2031-01-01T00:00:00Z"


@specleft(
    feature_id="feature-3-delegation",
    scenario_id="delegator-can-revoke-delegation-before-expiry",
)
def test_delegator_can_revoke_delegation_before_expiry(client):
    """Delegator can revoke delegation before expiry

    Priority: medium
    """
    with specleft.step("Given an active delegation"):
        author_id = "author-1"
        delegator_id = "reviewer-1"
        substitute_id = "reviewer-2"
        create_response = create_document(client, author_id=author_id)
        document_id = create_response.json()["id"]
        submit_document(
            client,
            document_id=document_id,
            author_id=author_id,
            reviewer_ids=[delegator_id],
        )
        delegation_response = create_delegation(
            client,
            document_id=document_id,
            delegator_id=delegator_id,
            substitute_id=substitute_id,
            expires_at="2031-01-01T00:00:00Z",
        )
        delegation_id = delegation_response.json()["id"]

    with specleft.step("When the delegator revokes the delegation"):
        revoke_response = client.post(
            f"/documents/{document_id}/delegations/{delegation_id}/revoke",
            json={"delegator_id": delegator_id},
        )
        assert revoke_response.status_code == 200

    with specleft.step("Then the substitute loses review permissions immediately"):
        approve_response = approve_document(
            client,
            document_id=document_id,
            actor_id=substitute_id,
            on_behalf_of=delegator_id,
        )
        assert_error(approve_response, status_code=403, code="delegation_inactive")

    with specleft.step("And subsequent actions by the substitute are rejected"):
        assert "revoked" in approve_response.json()["error"]["message"].lower()


@specleft(
    feature_id="feature-3-delegation",
    scenario_id="expired-delegation-is-rejected",
)
def test_expired_delegation_is_rejected(client):
    """Expired delegation is rejected

    Priority: medium
    """
    with specleft.step("Given a delegation that has passed its expiry date"):
        author_id = "author-1"
        delegator_id = "reviewer-1"
        substitute_id = "reviewer-2"
        create_response = create_document(client, author_id=author_id)
        document_id = create_response.json()["id"]
        submit_document(
            client,
            document_id=document_id,
            author_id=author_id,
            reviewer_ids=[delegator_id],
        )
        create_delegation(
            client,
            document_id=document_id,
            delegator_id=delegator_id,
            substitute_id=substitute_id,
            expires_at="2001-01-01T00:00:00Z",
        )

    with specleft.step("When the substitute attempts to approve the document"):
        approve_response = approve_document(
            client,
            document_id=document_id,
            actor_id=substitute_id,
            on_behalf_of=delegator_id,
        )

    with specleft.step("Then the approval is rejected"):
        assert_error(approve_response, status_code=403, code="delegation_expired")

    with specleft.step(
        "And an error is returned indicating the delegation has expired"
    ):
        assert "expired" in approve_response.json()["error"]["message"].lower()


@specleft(
    feature_id="feature-3-delegation",
    scenario_id="notes-2",
)
def test_notes_2(client):
    """Notes

    Priority: high
    """
    with specleft.step("Then delegation does not transfer to other documents"):
        author_id = "author-1"
        delegator_id = "reviewer-1"
        substitute_id = "reviewer-2"
        first_doc = create_document(client, author_id=author_id).json()["id"]
        second_doc = create_document(client, author_id=author_id).json()["id"]
        submit_document(
            client,
            document_id=first_doc,
            author_id=author_id,
            reviewer_ids=[delegator_id],
        )
        submit_document(
            client,
            document_id=second_doc,
            author_id=author_id,
            reviewer_ids=[delegator_id],
        )
        create_delegation(
            client,
            document_id=first_doc,
            delegator_id=delegator_id,
            substitute_id=substitute_id,
            expires_at="2031-01-01T00:00:00Z",
        )
        approve_other_response = approve_document(
            client,
            document_id=second_doc,
            actor_id=substitute_id,
            on_behalf_of=delegator_id,
        )
        assert_error(approve_other_response, status_code=403, code="delegation_missing")

    with specleft.step(
        "And a reviewer can only have one active delegation per document"
    ):
        duplicate_response = create_delegation(
            client,
            document_id=first_doc,
            delegator_id=delegator_id,
            substitute_id="reviewer-3",
            expires_at="2031-01-01T00:00:00Z",
        )
        assert_error(duplicate_response, status_code=409, code="delegation_exists")


@specleft(
    feature_id="feature-3-delegation",
    scenario_id="prevent-delegation-chain",
)
def test_prevent_delegation_chain(client):
    """Prevent delegation chain

    Priority: medium
    """
    with specleft.step("Given a substitute who has been delegated review authority"):
        author_id = "author-1"
        delegator_id = "reviewer-1"
        substitute_id = "reviewer-2"
        create_response = create_document(client, author_id=author_id)
        document_id = create_response.json()["id"]
        submit_document(
            client,
            document_id=document_id,
            author_id=author_id,
            reviewer_ids=[delegator_id],
        )
        create_delegation(
            client,
            document_id=document_id,
            delegator_id=delegator_id,
            substitute_id=substitute_id,
            expires_at="2031-01-01T00:00:00Z",
        )

    with specleft.step("When the substitute attempts to delegate to another person"):
        redelegation_response = create_delegation(
            client,
            document_id=document_id,
            delegator_id=substitute_id,
            substitute_id="reviewer-3",
            expires_at="2031-01-01T00:00:00Z",
        )

    with specleft.step("Then the delegation is rejected"):
        assert_error(
            redelegation_response, status_code=403, code="delegation_chain_forbidden"
        )

    with specleft.step(
        "And an error is returned indicating re-delegation is not permitted"
    ):
        assert (
            "re-delegation" in redelegation_response.json()["error"]["message"].lower()
        )


@specleft(
    feature_id="feature-3-delegation",
    scenario_id="substitute-can-approve-on-behalf-of-delegator",
)
def test_substitute_can_approve_on_behalf_of_delegator(client):
    """Substitute can approve on behalf of delegator

    Priority: medium
    """
    with specleft.step("Given a valid delegation that has not expired"):
        author_id = "author-1"
        delegator_id = "reviewer-1"
        substitute_id = "reviewer-2"
        create_response = create_document(client, author_id=author_id)
        document_id = create_response.json()["id"]
        submit_document(
            client,
            document_id=document_id,
            author_id=author_id,
            reviewer_ids=[delegator_id],
        )
        create_delegation(
            client,
            document_id=document_id,
            delegator_id=delegator_id,
            substitute_id=substitute_id,
            expires_at="2031-01-01T00:00:00Z",
        )

    with specleft.step("When the substitute approves the document"):
        approve_response = approve_document(
            client,
            document_id=document_id,
            actor_id=substitute_id,
            on_behalf_of=delegator_id,
        )
        assert approve_response.status_code == 200
        approve_payload = approve_response.json()

    with specleft.step(
        "Then the approval is recorded as the substitute acting on behalf of the delegator"
    ):
        assert approve_payload["decision"]["reviewer_id"] == delegator_id
        assert approve_payload["decision"]["acted_by"] == substitute_id

    with specleft.step("And the delegator's review requirement is satisfied"):
        fetch_response = client.get(f"/documents/{document_id}")
        assert fetch_response.json()["pending_reviewers"] == []

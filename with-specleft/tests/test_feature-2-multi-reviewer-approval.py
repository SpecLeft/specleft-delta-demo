"""
Auto-generated skeleton tests from Markdown specs.
Regenerate using: specleft test skeleton

Generated by SpecLeft - https://github.com/SpecLeft/specleft
"""

from specleft import specleft

from tests.helpers import (
    assert_error,
    create_document,
    get_document,
    submit_document,
)

# =============================================================================
# Feature: 2: Multi-Reviewer Approval
# ID: feature-2-multi-reviewer-approval
# --- confidence: medium source: prd assumptions: - Review decisions are immutable once recorded. - Decision timestamps use UTC. tags: - reviews - workflow component: api ---
# =============================================================================

# Story: Default
# ID: default


@specleft(
    feature_id="feature-2-multi-reviewer-approval",
    scenario_id="notes-1",
)
def test_notes_1(client):
    """Notes

    Priority: critical
    """
    with specleft.step("Then reviewer decisions are immutable once submitted"):
        author_id = "author-1"
        reviewer_id = "reviewer-1"
        create_response = create_document(client, author_id=author_id)
        document_id = create_response.json()["id"]
        submit_document(
            client,
            document_id=document_id,
            author_id=author_id,
            reviewer_ids=[reviewer_id],
        )
        approve_response = client.post(
            f"/documents/{document_id}/reviews/approve",
            json={"actor_id": reviewer_id},
        )
        assert approve_response.status_code == 200
        reject_response = client.post(
            f"/documents/{document_id}/reviews/reject",
            json={"actor_id": reviewer_id, "reason": "Changed mind"},
        )
        assert_error(reject_response, status_code=409, code="review_decision_exists")

    with specleft.step("And approval order does not matter"):
        author_id = "author-2"
        reviewers = ["reviewer-2", "reviewer-3"]
        create_response = create_document(client, author_id=author_id)
        second_document_id = create_response.json()["id"]
        submit_document(
            client,
            document_id=second_document_id,
            author_id=author_id,
            reviewer_ids=reviewers,
        )
        client.post(
            f"/documents/{second_document_id}/reviews/approve",
            json={"actor_id": reviewers[1]},
        )
        client.post(
            f"/documents/{second_document_id}/reviews/approve",
            json={"actor_id": reviewers[0]},
        )
        fetch_response = get_document(client, document_id=second_document_id)
        assert fetch_response.json()["status"] == "approved"


@specleft(
    feature_id="feature-2-multi-reviewer-approval",
    scenario_id="prevent-duplicate-approval-from-same-reviewer",
)
def test_prevent_duplicate_approval_from_same_reviewer(client):
    """Prevent duplicate approval from same reviewer

    Priority: medium
    """
    with specleft.step("Given a reviewer who has already approved a document"):
        author_id = "author-1"
        reviewer_id = "reviewer-1"
        create_response = create_document(client, author_id=author_id)
        document_id = create_response.json()["id"]
        submit_document(
            client,
            document_id=document_id,
            author_id=author_id,
            reviewer_ids=[reviewer_id],
        )
        approve_response = client.post(
            f"/documents/{document_id}/reviews/approve",
            json={"actor_id": reviewer_id},
        )
        assert approve_response.status_code == 200

    with specleft.step("When they attempt to approve the same document again"):
        duplicate_response = client.post(
            f"/documents/{document_id}/reviews/approve",
            json={"actor_id": reviewer_id},
        )

    with specleft.step("Then the request is rejected"):
        assert_error(duplicate_response, status_code=409, code="review_decision_exists")

    with specleft.step(
        "And an error is returned indicating they have already submitted a decision"
    ):
        assert "already" in duplicate_response.json()["error"]["message"].lower()


@specleft(
    feature_id="feature-2-multi-reviewer-approval",
    scenario_id="reject-if-any-reviewer-rejects",
)
def test_reject_if_any_reviewer_rejects(client):
    """Reject if any reviewer rejects

    Priority: medium
    """
    with specleft.step('Given a document in "review" status with multiple reviewers'):
        author_id = "author-1"
        reviewer_ids = ["reviewer-1", "reviewer-2"]
        create_response = create_document(client, author_id=author_id)
        document_id = create_response.json()["id"]
        submit_document(
            client,
            document_id=document_id,
            author_id=author_id,
            reviewer_ids=reviewer_ids,
        )

    with specleft.step("When one reviewer rejects the document"):
        reject_response = client.post(
            f"/documents/{document_id}/reviews/reject",
            json={"actor_id": reviewer_ids[0], "reason": "Nope"},
        )
        assert reject_response.status_code == 200

    with specleft.step('Then the document status changes to "rejected"'):
        fetch_response = get_document(client, document_id=document_id)
        assert fetch_response.json()["status"] == "rejected"

    with specleft.step("And remaining reviewers are no longer required to act"):
        assert fetch_response.json()["pending_reviewers"] == []


@specleft(
    feature_id="feature-2-multi-reviewer-approval",
    scenario_id="require-all-assigned-reviewers-to-approve",
)
def test_require_all_assigned_reviewers_to_approve(client):
    """Require all assigned reviewers to approve

    Priority: medium
    """
    with specleft.step(
        'Given a document in "review" status with three assigned reviewers'
    ):
        author_id = "author-1"
        reviewer_ids = ["reviewer-1", "reviewer-2", "reviewer-3"]
        create_response = create_document(client, author_id=author_id)
        document_id = create_response.json()["id"]
        submit_document(
            client,
            document_id=document_id,
            author_id=author_id,
            reviewer_ids=reviewer_ids,
        )

    with specleft.step("When only two reviewers have approved"):
        client.post(
            f"/documents/{document_id}/reviews/approve",
            json={"actor_id": reviewer_ids[0]},
        )
        client.post(
            f"/documents/{document_id}/reviews/approve",
            json={"actor_id": reviewer_ids[1]},
        )

    with specleft.step('Then the document remains in "review" status'):
        fetch_response = get_document(client, document_id=document_id)
        assert fetch_response.json()["status"] == "review"

    with specleft.step("And the pending reviewer is visible in the status response"):
        pending = fetch_response.json()["pending_reviewers"]
        assert reviewer_ids[2] in pending


@specleft(
    feature_id="feature-2-multi-reviewer-approval",
    scenario_id="track-individual-reviewer-decisions-with-timestamps",
)
def test_track_individual_reviewer_decisions_with_timestamps(client):
    """Track individual reviewer decisions with timestamps

    Priority: medium
    """
    with specleft.step('Given a document in "review" status'):
        author_id = "author-1"
        reviewer_id = "reviewer-1"
        create_response = create_document(client, author_id=author_id)
        document_id = create_response.json()["id"]
        submit_document(
            client,
            document_id=document_id,
            author_id=author_id,
            reviewer_ids=[reviewer_id],
        )

    with specleft.step("When a reviewer submits their decision"):
        approve_response = client.post(
            f"/documents/{document_id}/reviews/approve",
            json={"actor_id": reviewer_id},
        )
        assert approve_response.status_code == 200

    with specleft.step(
        "Then the decision is recorded with the reviewer ID and timestamp"
    ):
        history_response = client.get(f"/documents/{document_id}/reviews")
        assert history_response.status_code == 200
        decisions = history_response.json()["items"]
        assert decisions[0]["reviewer_id"] == reviewer_id
        assert decisions[0]["decided_at"]

    with specleft.step("And the decision is visible in the document review history"):
        assert decisions[0]["status"] == "approved"
